"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _utilsCharNeighbor = require("../../utils/charNeighbor");

var _utilsCharNeighbor2 = _interopRequireDefault(_utilsCharNeighbor);

var _utilsIsSingleLineString = require("../../utils/isSingleLineString");

var _utilsIsSingleLineString2 = _interopRequireDefault(_utilsIsSingleLineString);

var ruleName = "block-opening-brace-after";
exports.ruleName = ruleName;
var messages = {
  expected: function expected(w) {
    return "Expected " + (w === "space" ? "single space" : w) + " " + ("before block (" + ruleName + ")");
  } };

exports.messages = messages;
var whitespaceKeywordMap = {
  space: " ",
  newline: "\n" };

/**
 * Below, "whitespace" should be a string matching
 * one of the `whitespaceKeywordMap` defined above.
 *
 * @param {string|object} options -
 *   If string: Whitespace expected after every block's `{`.
 *   If object: The following options
 * @param {string} [options.singleLine] - Whitespace expected
 *   after single-line blocks' `{`
 * @param {string} [options.multiLine] - Whitespace expected
 *   after multi-line blocks' `{`
 */

exports["default"] = function (options) {
  var oneWhitespace = typeof options === "string";
  var singleLineWhitespaceKeyword = oneWhitespace ? options : options.singleLine;
  var multiLineWhitespaceKeyword = oneWhitespace ? options : options.multiLine;

  return function (css, result) {

    // Check both kinds of "block": rules and at-rules
    css.eachRule(checkBlock);
    css.eachAtRule(checkBlock);

    function checkBlock(block) {
      var blockString = block.toString();

      var expectedWhitespaceKeyword = (0, _utilsIsSingleLineString2["default"])(blockString) ? singleLineWhitespaceKeyword : multiLineWhitespaceKeyword;

      var expectedChar = whitespaceKeywordMap[expectedWhitespaceKeyword];
      var actualChar = (0, _utilsCharNeighbor2["default"])(blockString, "{", 1);

      if (actualChar === expectedChar) {
        return;
      }
      result.warn(messages.expected(expectedWhitespaceKeyword), { node: block });
    }
  };
};