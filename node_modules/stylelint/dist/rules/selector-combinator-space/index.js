"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _utils = require("../../utils");

var ruleName = "selector-combinator-space";

exports.ruleName = ruleName;
var messages = (0, _utils.standardWhitespaceMessages)(ruleName, {
  expectedBefore: function expectedBefore(c) {
    return "Expected single space before combinator \"" + c + "\"";
  },
  rejectedBefore: function rejectedBefore(c) {
    return "Expected no space before combinator \"" + c + "\"";
  },
  expectedAfter: function expectedAfter(c) {
    return "Expected single space after combinator \"" + c + "\"";
  },
  rejectedAfter: function rejectedAfter(c) {
    return "Expected no space after combinator \"" + c + "\"";
  } });

exports.messages = messages;
var combinators = [">", "+", "~"];

/**
 * @param {object} options
 * @param {"always"|"never"} [options.before]
 * @param {"always"|"never"} [options.after]
 */

exports["default"] = function (options) {
  var spaceOptions = (0, _utils.standardWhitespaceOptions)(options);
  var spaceChecker = (0, _utils.standardWhitespaceChecker)(" ", spaceOptions, messages);

  return function (css, result) {
    css.eachRule(function (rule) {
      var selector = rule.selector;
      _lodash2["default"].forEach(selector, function (char, i) {
        if (!_lodash2["default"].includes(combinators, char)) {
          return;
        }
        spaceChecker.before(selector, i, function (msg) {
          result.warn(msg, { node: rule });
        });
        spaceChecker.after(selector, i, function (msg) {
          result.warn(msg, { node: rule });
        });
      });
    });
  };
};